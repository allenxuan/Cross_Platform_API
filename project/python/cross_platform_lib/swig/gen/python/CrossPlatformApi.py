# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _CrossPlatformApi
else:
    import _CrossPlatformApi

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _CrossPlatformApi.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CrossPlatformApi.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _CrossPlatformApi.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _CrossPlatformApi.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _CrossPlatformApi.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _CrossPlatformApi.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _CrossPlatformApi.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _CrossPlatformApi.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _CrossPlatformApi.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _CrossPlatformApi.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _CrossPlatformApi.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _CrossPlatformApi.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _CrossPlatformApi.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _CrossPlatformApi:
_CrossPlatformApi.SwigPyIterator_swigregister(SwigPyIterator)

class StrVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.StrVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CrossPlatformApi.StrVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CrossPlatformApi.StrVec___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _CrossPlatformApi.StrVec___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _CrossPlatformApi.StrVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CrossPlatformApi.StrVec___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _CrossPlatformApi.StrVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CrossPlatformApi.StrVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _CrossPlatformApi.StrVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CrossPlatformApi.StrVec___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _CrossPlatformApi.StrVec_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _CrossPlatformApi.StrVec_append(self, x)

    def empty(self) -> "bool":
        return _CrossPlatformApi.StrVec_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _CrossPlatformApi.StrVec_size(self)

    def swap(self, v: "StrVec") -> "void":
        return _CrossPlatformApi.StrVec_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _CrossPlatformApi.StrVec_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _CrossPlatformApi.StrVec_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _CrossPlatformApi.StrVec_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _CrossPlatformApi.StrVec_rend(self)

    def clear(self) -> "void":
        return _CrossPlatformApi.StrVec_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _CrossPlatformApi.StrVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _CrossPlatformApi.StrVec_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _CrossPlatformApi.StrVec_erase(self, *args)

    def __init__(self, *args):
        _CrossPlatformApi.StrVec_swiginit(self, _CrossPlatformApi.new_StrVec(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _CrossPlatformApi.StrVec_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _CrossPlatformApi.StrVec_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _CrossPlatformApi.StrVec_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _CrossPlatformApi.StrVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CrossPlatformApi.StrVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CrossPlatformApi.StrVec_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _CrossPlatformApi.StrVec_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _CrossPlatformApi.StrVec_capacity(self)
    __swig_destroy__ = _CrossPlatformApi.delete_StrVec

# Register StrVec in _CrossPlatformApi:
_CrossPlatformApi.StrVec_swigregister(StrVec)

class DataVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CrossPlatformApi.DataVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CrossPlatformApi.DataVec___bool__(self)

    def __len__(self) -> "std::vector< cross_platform_common::Data >::size_type":
        return _CrossPlatformApi.DataVec___len__(self)

    def __getslice__(self, i: "std::vector< cross_platform_common::Data >::difference_type", j: "std::vector< cross_platform_common::Data >::difference_type") -> "std::vector< cross_platform_common::Data,std::allocator< cross_platform_common::Data > > *":
        return _CrossPlatformApi.DataVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CrossPlatformApi.DataVec___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< cross_platform_common::Data >::difference_type", j: "std::vector< cross_platform_common::Data >::difference_type") -> "void":
        return _CrossPlatformApi.DataVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CrossPlatformApi.DataVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< cross_platform_common::Data >::value_type const &":
        return _CrossPlatformApi.DataVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CrossPlatformApi.DataVec___setitem__(self, *args)

    def pop(self) -> "std::vector< cross_platform_common::Data >::value_type":
        return _CrossPlatformApi.DataVec_pop(self)

    def append(self, x: "Data") -> "void":
        return _CrossPlatformApi.DataVec_append(self, x)

    def empty(self) -> "bool":
        return _CrossPlatformApi.DataVec_empty(self)

    def size(self) -> "std::vector< cross_platform_common::Data >::size_type":
        return _CrossPlatformApi.DataVec_size(self)

    def swap(self, v: "DataVec") -> "void":
        return _CrossPlatformApi.DataVec_swap(self, v)

    def begin(self) -> "std::vector< cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataVec_begin(self)

    def end(self) -> "std::vector< cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataVec_end(self)

    def rbegin(self) -> "std::vector< cross_platform_common::Data >::reverse_iterator":
        return _CrossPlatformApi.DataVec_rbegin(self)

    def rend(self) -> "std::vector< cross_platform_common::Data >::reverse_iterator":
        return _CrossPlatformApi.DataVec_rend(self)

    def clear(self) -> "void":
        return _CrossPlatformApi.DataVec_clear(self)

    def get_allocator(self) -> "std::vector< cross_platform_common::Data >::allocator_type":
        return _CrossPlatformApi.DataVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _CrossPlatformApi.DataVec_pop_back(self)

    def erase(self, *args) -> "std::vector< cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataVec_erase(self, *args)

    def __init__(self, *args):
        _CrossPlatformApi.DataVec_swiginit(self, _CrossPlatformApi.new_DataVec(*args))

    def push_back(self, x: "Data") -> "void":
        return _CrossPlatformApi.DataVec_push_back(self, x)

    def front(self) -> "std::vector< cross_platform_common::Data >::value_type const &":
        return _CrossPlatformApi.DataVec_front(self)

    def back(self) -> "std::vector< cross_platform_common::Data >::value_type const &":
        return _CrossPlatformApi.DataVec_back(self)

    def assign(self, n: "std::vector< cross_platform_common::Data >::size_type", x: "Data") -> "void":
        return _CrossPlatformApi.DataVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CrossPlatformApi.DataVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CrossPlatformApi.DataVec_insert(self, *args)

    def reserve(self, n: "std::vector< cross_platform_common::Data >::size_type") -> "void":
        return _CrossPlatformApi.DataVec_reserve(self, n)

    def capacity(self) -> "std::vector< cross_platform_common::Data >::size_type":
        return _CrossPlatformApi.DataVec_capacity(self)
    __swig_destroy__ = _CrossPlatformApi.delete_DataVec

# Register DataVec in _CrossPlatformApi:
_CrossPlatformApi.DataVec_swigregister(DataVec)

class DataSharePtrVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataSharePtrVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CrossPlatformApi.DataSharePtrVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CrossPlatformApi.DataSharePtrVec___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::size_type":
        return _CrossPlatformApi.DataSharePtrVec___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< cross_platform_common::Data > >::difference_type", j: "std::vector< std::shared_ptr< cross_platform_common::Data > >::difference_type") -> "std::vector< std::shared_ptr< cross_platform_common::Data >,std::allocator< std::shared_ptr< cross_platform_common::Data > > > *":
        return _CrossPlatformApi.DataSharePtrVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrVec___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< cross_platform_common::Data > >::difference_type", j: "std::vector< std::shared_ptr< cross_platform_common::Data > >::difference_type") -> "void":
        return _CrossPlatformApi.DataSharePtrVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type const &":
        return _CrossPlatformApi.DataSharePtrVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrVec___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type":
        return _CrossPlatformApi.DataSharePtrVec_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type const &") -> "void":
        return _CrossPlatformApi.DataSharePtrVec_append(self, x)

    def empty(self) -> "bool":
        return _CrossPlatformApi.DataSharePtrVec_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::size_type":
        return _CrossPlatformApi.DataSharePtrVec_size(self)

    def swap(self, v: "DataSharePtrVec") -> "void":
        return _CrossPlatformApi.DataSharePtrVec_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrVec_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrVec_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::reverse_iterator":
        return _CrossPlatformApi.DataSharePtrVec_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::reverse_iterator":
        return _CrossPlatformApi.DataSharePtrVec_rend(self)

    def clear(self) -> "void":
        return _CrossPlatformApi.DataSharePtrVec_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::allocator_type":
        return _CrossPlatformApi.DataSharePtrVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _CrossPlatformApi.DataSharePtrVec_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrVec_erase(self, *args)

    def __init__(self, *args):
        _CrossPlatformApi.DataSharePtrVec_swiginit(self, _CrossPlatformApi.new_DataSharePtrVec(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type const &") -> "void":
        return _CrossPlatformApi.DataSharePtrVec_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type const &":
        return _CrossPlatformApi.DataSharePtrVec_front(self)

    def back(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type const &":
        return _CrossPlatformApi.DataSharePtrVec_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< cross_platform_common::Data > >::size_type", x: "std::vector< std::shared_ptr< cross_platform_common::Data > >::value_type const &") -> "void":
        return _CrossPlatformApi.DataSharePtrVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrVec_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< cross_platform_common::Data > >::size_type") -> "void":
        return _CrossPlatformApi.DataSharePtrVec_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data > >::size_type":
        return _CrossPlatformApi.DataSharePtrVec_capacity(self)
    __swig_destroy__ = _CrossPlatformApi.delete_DataSharePtrVec

# Register DataSharePtrVec in _CrossPlatformApi:
_CrossPlatformApi.DataSharePtrVec_swigregister(DataSharePtrVec)

class DataMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CrossPlatformApi.DataMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CrossPlatformApi.DataMap___bool__(self)

    def __len__(self) -> "std::map< std::string,cross_platform_common::Data >::size_type":
        return _CrossPlatformApi.DataMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "std::map< std::string,cross_platform_common::Data >::mapped_type const &":
        return _CrossPlatformApi.DataMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "void":
        return _CrossPlatformApi.DataMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "bool":
        return _CrossPlatformApi.DataMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CrossPlatformApi.DataMap_keys(self)

    def values(self) -> "PyObject *":
        return _CrossPlatformApi.DataMap_values(self)

    def items(self) -> "PyObject *":
        return _CrossPlatformApi.DataMap_items(self)

    def __contains__(self, key: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "bool":
        return _CrossPlatformApi.DataMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CrossPlatformApi.DataMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CrossPlatformApi.DataMap_asdict(self)

    def __init__(self, *args):
        _CrossPlatformApi.DataMap_swiginit(self, _CrossPlatformApi.new_DataMap(*args))

    def empty(self) -> "bool":
        return _CrossPlatformApi.DataMap_empty(self)

    def size(self) -> "std::map< std::string,cross_platform_common::Data >::size_type":
        return _CrossPlatformApi.DataMap_size(self)

    def swap(self, v: "DataMap") -> "void":
        return _CrossPlatformApi.DataMap_swap(self, v)

    def begin(self) -> "std::map< std::string,cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataMap_begin(self)

    def end(self) -> "std::map< std::string,cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataMap_end(self)

    def rbegin(self) -> "std::map< std::string,cross_platform_common::Data >::reverse_iterator":
        return _CrossPlatformApi.DataMap_rbegin(self)

    def rend(self) -> "std::map< std::string,cross_platform_common::Data >::reverse_iterator":
        return _CrossPlatformApi.DataMap_rend(self)

    def clear(self) -> "void":
        return _CrossPlatformApi.DataMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,cross_platform_common::Data >::allocator_type":
        return _CrossPlatformApi.DataMap_get_allocator(self)

    def count(self, x: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "std::map< std::string,cross_platform_common::Data >::size_type":
        return _CrossPlatformApi.DataMap_count(self, x)

    def erase(self, *args) -> "void":
        return _CrossPlatformApi.DataMap_erase(self, *args)

    def find(self, x: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "std::map< std::string,cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "std::map< std::string,cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,cross_platform_common::Data >::key_type const &") -> "std::map< std::string,cross_platform_common::Data >::iterator":
        return _CrossPlatformApi.DataMap_upper_bound(self, x)
    __swig_destroy__ = _CrossPlatformApi.delete_DataMap

# Register DataMap in _CrossPlatformApi:
_CrossPlatformApi.DataMap_swigregister(DataMap)

class DataSharePtrMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataSharePtrMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CrossPlatformApi.DataSharePtrMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CrossPlatformApi.DataSharePtrMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::size_type":
        return _CrossPlatformApi.DataSharePtrMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::mapped_type const &":
        return _CrossPlatformApi.DataSharePtrMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "void":
        return _CrossPlatformApi.DataSharePtrMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "bool":
        return _CrossPlatformApi.DataSharePtrMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CrossPlatformApi.DataSharePtrMap_keys(self)

    def values(self) -> "PyObject *":
        return _CrossPlatformApi.DataSharePtrMap_values(self)

    def items(self) -> "PyObject *":
        return _CrossPlatformApi.DataSharePtrMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "bool":
        return _CrossPlatformApi.DataSharePtrMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataSharePtrMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CrossPlatformApi.DataSharePtrMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CrossPlatformApi.DataSharePtrMap_asdict(self)

    def __init__(self, *args):
        _CrossPlatformApi.DataSharePtrMap_swiginit(self, _CrossPlatformApi.new_DataSharePtrMap(*args))

    def empty(self) -> "bool":
        return _CrossPlatformApi.DataSharePtrMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::size_type":
        return _CrossPlatformApi.DataSharePtrMap_size(self)

    def swap(self, v: "DataSharePtrMap") -> "void":
        return _CrossPlatformApi.DataSharePtrMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::reverse_iterator":
        return _CrossPlatformApi.DataSharePtrMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::reverse_iterator":
        return _CrossPlatformApi.DataSharePtrMap_rend(self)

    def clear(self) -> "void":
        return _CrossPlatformApi.DataSharePtrMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::allocator_type":
        return _CrossPlatformApi.DataSharePtrMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::size_type":
        return _CrossPlatformApi.DataSharePtrMap_count(self, x)

    def erase(self, *args) -> "void":
        return _CrossPlatformApi.DataSharePtrMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::key_type const &") -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data > >::iterator":
        return _CrossPlatformApi.DataSharePtrMap_upper_bound(self, x)
    __swig_destroy__ = _CrossPlatformApi.delete_DataSharePtrMap

# Register DataSharePtrMap in _CrossPlatformApi:
_CrossPlatformApi.DataSharePtrMap_swigregister(DataSharePtrMap)

class DataPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _CrossPlatformApi.DataPair_swiginit(self, _CrossPlatformApi.new_DataPair(*args))
    first = property(_CrossPlatformApi.DataPair_first_get, _CrossPlatformApi.DataPair_first_set)
    second = property(_CrossPlatformApi.DataPair_second_get, _CrossPlatformApi.DataPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _CrossPlatformApi.delete_DataPair

# Register DataPair in _CrossPlatformApi:
_CrossPlatformApi.DataPair_swigregister(DataPair)

class DataSharedPtrPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _CrossPlatformApi.DataSharedPtrPair_swiginit(self, _CrossPlatformApi.new_DataSharedPtrPair(*args))
    first = property(_CrossPlatformApi.DataSharedPtrPair_first_get, _CrossPlatformApi.DataSharedPtrPair_first_set)
    second = property(_CrossPlatformApi.DataSharedPtrPair_second_get, _CrossPlatformApi.DataSharedPtrPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _CrossPlatformApi.delete_DataSharedPtrPair

# Register DataSharedPtrPair in _CrossPlatformApi:
_CrossPlatformApi.DataSharedPtrPair_swigregister(DataSharedPtrPair)

kType1 = _CrossPlatformApi.kType1
kType2 = _CrossPlatformApi.kType2
kType3 = _CrossPlatformApi.kType3
class Data(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _CrossPlatformApi.Data_swiginit(self, _CrossPlatformApi.new_Data())
    __swig_destroy__ = _CrossPlatformApi.delete_Data
    type = property(_CrossPlatformApi.Data_type_get, _CrossPlatformApi.Data_type_set)
    a_data = property(_CrossPlatformApi.Data_a_data_get, _CrossPlatformApi.Data_a_data_set)

# Register Data in _CrossPlatformApi:
_CrossPlatformApi.Data_swigregister(Data)

class DataChild(Data):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _CrossPlatformApi.DataChild_swiginit(self, _CrossPlatformApi.new_DataChild())
    __swig_destroy__ = _CrossPlatformApi.delete_DataChild

    @staticmethod
    def DynamicCast(data: "std::shared_ptr< cross_platform_common::Data > const &") -> "std::shared_ptr< cross_platform_common::DataChild >":
        return _CrossPlatformApi.DataChild_DynamicCast(data)
    a_child_data = property(_CrossPlatformApi.DataChild_a_child_data_get, _CrossPlatformApi.DataChild_a_child_data_set)

# Register DataChild in _CrossPlatformApi:
_CrossPlatformApi.DataChild_swigregister(DataChild)

def DataChild_DynamicCast(data: "std::shared_ptr< cross_platform_common::Data > const &") -> "std::shared_ptr< cross_platform_common::DataChild >":
    return _CrossPlatformApi.DataChild_DynamicCast(data)

class DataGrandChild(DataChild):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _CrossPlatformApi.DataGrandChild_swiginit(self, _CrossPlatformApi.new_DataGrandChild())
    __swig_destroy__ = _CrossPlatformApi.delete_DataGrandChild

    @staticmethod
    def DynamicCast(data: "std::shared_ptr< cross_platform_common::Data > const &") -> "std::shared_ptr< cross_platform_common::DataGrandChild >":
        return _CrossPlatformApi.DataGrandChild_DynamicCast(data)
    a_grand_child_data = property(_CrossPlatformApi.DataGrandChild_a_grand_child_data_get, _CrossPlatformApi.DataGrandChild_a_grand_child_data_set)

# Register DataGrandChild in _CrossPlatformApi:
_CrossPlatformApi.DataGrandChild_swigregister(DataGrandChild)

def DataGrandChild_DynamicCast(data: "std::shared_ptr< cross_platform_common::Data > const &") -> "std::shared_ptr< cross_platform_common::DataGrandChild >":
    return _CrossPlatformApi.DataGrandChild_DynamicCast(data)

class Model(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a_uint64 = property(_CrossPlatformApi.Model_a_uint64_get, _CrossPlatformApi.Model_a_uint64_set)
    a_float = property(_CrossPlatformApi.Model_a_float_get, _CrossPlatformApi.Model_a_float_set)
    a_string = property(_CrossPlatformApi.Model_a_string_get, _CrossPlatformApi.Model_a_string_set)
    a_string_vector = property(_CrossPlatformApi.Model_a_string_vector_get, _CrossPlatformApi.Model_a_string_vector_set)

    def __init__(self):
        _CrossPlatformApi.Model_swiginit(self, _CrossPlatformApi.new_Model())
    __swig_destroy__ = _CrossPlatformApi.delete_Model

# Register Model in _CrossPlatformApi:
_CrossPlatformApi.Model_swigregister(Model)

class ModelCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == ModelCallback:
            _self = None
        else:
            _self = self
        _CrossPlatformApi.ModelCallback_swiginit(self, _CrossPlatformApi.new_ModelCallback(_self, ))
    __swig_destroy__ = _CrossPlatformApi.delete_ModelCallback

    def onModelChangedPtr(self, model_ptr: "Model") -> "void":
        return _CrossPlatformApi.ModelCallback_onModelChangedPtr(self, model_ptr)

    def onModelChangedSharedPtr(self, model_shared_ptr: "std::shared_ptr< cross_platform_external::Model >") -> "void":
        return _CrossPlatformApi.ModelCallback_onModelChangedSharedPtr(self, model_shared_ptr)
    def __disown__(self):
        self.this.disown()
        _CrossPlatformApi.disown_ModelCallback(self)
        return weakref.proxy(self)

# Register ModelCallback in _CrossPlatformApi:
_CrossPlatformApi.ModelCallback_swigregister(ModelCallback)

class ApiCenter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _CrossPlatformApi.ApiCenter_swiginit(self, _CrossPlatformApi.new_ApiCenter())
    __swig_destroy__ = _CrossPlatformApi.delete_ApiCenter

    def registerModelCallback(self, callback: "std::shared_ptr< cross_platform_common::ModelCallback > const &") -> "void":
        return _CrossPlatformApi.ApiCenter_registerModelCallback(self, callback)

    def unRegisterModelCallback(self, callback: "std::shared_ptr< cross_platform_common::ModelCallback > const &") -> "void":
        return _CrossPlatformApi.ApiCenter_unRegisterModelCallback(self, callback)

    def getModelPtr(self) -> "cross_platform_external::Model &":
        r"""
        :rtype: :py:class:`Model`
        :return: plain reference
        """
        return _CrossPlatformApi.ApiCenter_getModelPtr(self)

    def getModelSharedPtr(self) -> "std::shared_ptr< cross_platform_external::Model >":
        r"""
        :rtype: :py:class:`Model`
        :return: shared_ptr by value
        """
        return _CrossPlatformApi.ApiCenter_getModelSharedPtr(self)

    def sumIntAndFloat(self) -> "float":
        return _CrossPlatformApi.ApiCenter_sumIntAndFloat(self)

    def setUint64(self, a_uint64_t: "uint64_t") -> "void":
        return _CrossPlatformApi.ApiCenter_setUint64(self, a_uint64_t)

    def getUnit64(self) -> "uint64_t":
        return _CrossPlatformApi.ApiCenter_getUnit64(self)

    def setFloat(self, a_float: "float") -> "void":
        return _CrossPlatformApi.ApiCenter_setFloat(self, a_float)

    def getFloat(self) -> "float":
        return _CrossPlatformApi.ApiCenter_getFloat(self)

    def getBool(self) -> "bool":
        return _CrossPlatformApi.ApiCenter_getBool(self)

    def setBool(self, b: "bool") -> "void":
        return _CrossPlatformApi.ApiCenter_setBool(self, b)

    def getString(self) -> "std::string":
        return _CrossPlatformApi.ApiCenter_getString(self)

    def setString(self, string: "std::string const &") -> "void":
        return _CrossPlatformApi.ApiCenter_setString(self, string)

    def setStringVector(self, vector: "StrVec") -> "void":
        return _CrossPlatformApi.ApiCenter_setStringVector(self, vector)

    def getStringVector(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _CrossPlatformApi.ApiCenter_getStringVector(self)

    def setDataVector(self, data_vector: "DataVec") -> "void":
        return _CrossPlatformApi.ApiCenter_setDataVector(self, data_vector)

    def getDataVectorRef(self) -> "std::vector< cross_platform_common::Data,std::allocator< cross_platform_common::Data > > &":
        return _CrossPlatformApi.ApiCenter_getDataVectorRef(self)

    def setDataSharedPtrVector(self, data_shared_ptr_vector: "DataSharePtrVec") -> "void":
        return _CrossPlatformApi.ApiCenter_setDataSharedPtrVector(self, data_shared_ptr_vector)

    def getDataSharedPtrVector(self) -> "std::vector< std::shared_ptr< cross_platform_common::Data >,std::allocator< std::shared_ptr< cross_platform_common::Data > > >":
        return _CrossPlatformApi.ApiCenter_getDataSharedPtrVector(self)

    def setDataMap(self, data_map: "DataMap") -> "void":
        return _CrossPlatformApi.ApiCenter_setDataMap(self, data_map)

    def getDataMapRef(self) -> "std::map< std::string,cross_platform_common::Data,std::less< std::string >,std::allocator< std::pair< std::string const,cross_platform_common::Data > > > &":
        return _CrossPlatformApi.ApiCenter_getDataMapRef(self)

    def setDataSharedPtrMap(self, a_data_shared_ptr_map: "DataSharePtrMap") -> "void":
        return _CrossPlatformApi.ApiCenter_setDataSharedPtrMap(self, a_data_shared_ptr_map)

    def getDataSharedPtrMap(self) -> "std::map< std::string,std::shared_ptr< cross_platform_common::Data >,std::less< std::string >,std::allocator< std::pair< std::string const,std::shared_ptr< cross_platform_common::Data > > > >":
        return _CrossPlatformApi.ApiCenter_getDataSharedPtrMap(self)

    def setDataPair(self, a_data_pair: "DataPair") -> "void":
        return _CrossPlatformApi.ApiCenter_setDataPair(self, a_data_pair)

    def getDataPairRef(self) -> "std::pair< std::string,cross_platform_common::Data > &":
        return _CrossPlatformApi.ApiCenter_getDataPairRef(self)

    def setDataSharedPtrPair(self, a_data_shared_ptr_pair: "DataSharedPtrPair") -> "void":
        return _CrossPlatformApi.ApiCenter_setDataSharedPtrPair(self, a_data_shared_ptr_pair)

    def getDataSharedPtrPair(self) -> "std::pair< std::string,std::shared_ptr< cross_platform_common::Data > >":
        return _CrossPlatformApi.ApiCenter_getDataSharedPtrPair(self)

# Register ApiCenter in _CrossPlatformApi:
_CrossPlatformApi.ApiCenter_swigregister(ApiCenter)



